To ensure that our method scales to high resolutions, we solve the equations of elasticity using a multigrid technique. In fact, we explored two possible approaches: the first option is to construct a multigrid cycle purely as a solver for
the linear system (\ref{eqn_newton_step}) generated in every Newton-Raphson step. The other possibility is to implement a fully nonlinear multigrid cycle, based on the Full
Approximation Scheme (FAS) which would replace and accelerate the entire sequence of Newton iterations. This section details several design subtleties, and algorithmic modifications
that were necessary to efficiently implement these two multigrid schemes. 

\paragraph{Domain description} Our discretization is based on a voxelized representation of the elastic body. At any given resolution, a cubic background lattice is defined and
its cells are labeled either \emph{internal} or \emph{external} depending on any material overlap with the embedded deforming body. Internal cells can optionally be labeled as
\emph{constrained} (or Dirichlet) if the trajectories of their nodes will be specified as hard kinematic constraints. The Lam\'{e} coefficients $\mu$ and $\lambda$ can be specified for
each individual cell, allowing for inhomogeneous models. The coarser domains of a multigrid hierarchy are generated by a simple binary coarsening strategy. Similar to
\cite{Zhu:2010:EMM} a label of constrained, internal or external is assigned in this order of priority, if fine children with more than one type are present. The Lam\'{e} parameters of
coarse interior cells are computed by summing the $\mu$ or $\lambda$ of any \emph{interior} children, and dividing by eight; thus coarse cells overlapping with the boundary receive
lower material parameters, to account for the partial material coverage of the cell.

\paragraph{Elasticity coarsening} A multigrid method requires us to generate a hierarchy of discretizations. Specifically, if we use multigrid to solve the linear system
(\ref{eqn_newton_step}), different versions of $\mathbf{K}$, denoted by $\mathbf{K}^h,\mathbf{K}^{2h},\mathbf{K}^{4h},\ldots$ need to be computed for every level of the multigrid
hierarchy. We specifically avoid the Galerkin coarsening strategy since it requires forming the stiffness matrices explicitly. The alternative is a 
matrix-free approach which constructs $\mathbf{K}^{2h}$ from a re-discretization of our problem at the coarse grid. We can repeat the same process followed at the fine grid, and
define coarse forces $\vec{f}^{2h}(\vec{x}^{2h})=-\partial\Psi^{2h}/\partial\vec{x}^{2h}$ as well as a coarse stiffness $\mathbf{K}^{2h}=\partial\vec{f}^{2h}/\partial\vec{x}^{2h}$ and
encode these in a matrix-free fashion as before. 

The challenge however is that the entries in $\mathbf{K}^{2h}$ depend on the current estimate of the solution and, more accurately, on a
\emph{coarse grid} version $\vec{x}^{2h}$ of this estimate. The general methodology is to define yet another restriction operator $\hat{\mathcal{R}}$ (possibly different than the
$\mathcal{R}$ used to restrict residuals) to downsample the solution estimate as $\vec{x}^{2h}=\hat{\mathcal{R}}\vec{x}^h$. However, as a consequence of our geometric domain coarsening
as described, the discrete domain \emph{grows} in size, as coarse cells with any interior children will now be considered fully interior, even if they include some
exterior cells from the fine grid. Therefore, restricting the approximation $\vec{x}^h$ would require extrapolation of the deformation field. We found such extrapolations to be
quite unstable, especially in the presence of collisions, and sometimes even ill-defined near concave, high curvature boundaries.

Our solution is based on the observation that the entries of $\mathbf{K}$ do not depend directly on the positions $\vec{x}$, but only through the deformation gradient $\mathbf{F}$. Note
that this is also true for our stabilized discretization; the part $\mathbf{K}_\Delta$ of the stiffness matrix due to $\Psi_\Delta$ is a \emph{constant} matrix, not dependent on positions
at all. The auxiliary part $\mathbf{K}_{\mbox{\small aux}}$ due to $\Psi_{\mbox{\small aux}}$ is fully determined by the discrete deformation gradient $\mathbf{F}^e$ at every
cell. Thus, instead of restricting $\vec{x}^h\rightarrow\vec{x}^{2h}$ we downsample the deformation gradient as $\mathbf{F}^h\rightarrow\mathbf{F}^{2h}$, which is done with
simple weighted averaging. 

Once the stiffness matrices have been constructed for all levels, the V-Cycle described in Algorithm \ref{alg_linear_vcycle} is used to solve the linearized
Newton equation. The restriction and prolongation operators are constructed based on trilinear interpolation. Since we do not explicitly construct $\mathbf{K}$, we use a
Jacobi smoother instead of a Gauss-Seidel one, since for the Jacobi procedure all force differentials may be computed in parallel. Note however that the elasticity matrix is not
diagonally dominant, and the Jacobi procedure needs to be damped for stable convergence. We found that the damping coefficient could safely be as high as $0.8$ in the interior of the
object, while values of $0.3-0.4$ were more appropriate near the boundary, near soft constraints, and for higher values of Poisson's ratio.

\begin{algorithm}[h]
\caption{Linear Multigrid V(1,1) Cycle for equation (\ref{eqn_newton_step})}\label{alg_linear_vcycle}
\begin{algorithmic}[1]
\Procedure{LinearVCycle}{}
\State $\vec{b}^h\gets \vec{f}^h(\vec{x}^h)+\vec{g}^h$
\For{$l= 0 \textbf{\ to\ }L$$-$$1$}\Comment{total of $L$$+$$1$ levels}
\State Smooth($\mathbf{K}^{2^lh}$,$\delta\vec{x}^{2^lh}$,$\vec{b}^{2^lh}$)
\State $\vec{r}^{2^lh}\gets\vec{b}^{2^lh}-\mathbf{K}^{2^lh}\delta\vec{x}^{2^lh}$
\State $\vec{b}^{2^{l+1}h}\gets$Restrict($\vec{r}^{2^lh}$),\ $\delta\vec{x}^{2^{l+1}h}\gets 0$
\EndFor
\State Solve $\delta\vec{x}^{2^Lh}\gets (\mathbf{K}^{2^Lh})^{-1}\vec{b}^{2^Lh}$
\For{$l=L$$-$$1 \textbf{\ down to\ } 0$}
\State $\delta\vec{x}^{2^lh}\gets \delta\vec{x}^{2^lh}+$Prolongate($\delta\vec{x}^{2^{l+1}h}$)
\State Smooth($\mathbf{K}^{2^lh}$,$\delta\vec{x}^{2^lh}$,$\vec{b}^{2^lh}$)
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\paragraph{Point constraint coarsening} Each soft constraint and active collision proxy is copied to the coarse grids based on its material location.  Its associated stiffness modulus is scaled by a factor of .125 (or .25 in 2D) to accommodate its embedding in a larger element.  Otherwise, the coarsened proxies are then treated in the same manner at every level of the hierarchy.

\paragraph{Nonlinear multigrid} We also implemented a fully nonlinear multigrid
solver, based on the Full Approximation Scheme (FAS) approach. As before, the
challenge is  that the nonlinear force operator requires a coarse grid version of the solution estimate. Once
again, the operator only depends on $\vec{x}$ through the deformation gradient;
unfortunately the deformation gradient does not stay fixed through smoothing and
v-cycles, requiring constant updates.  We consider the restricted value of the
deformation gradient as an ``offset'' (denoted by $\mathbf{F}_{\mbox{\small off}}$) and change
our state variables for the coarser grids from \emph{positions} ($\vec{x}$) to
\emph{corrections} ($\vec{u}$) from this offset. We compute the updated deformation  as
$\mathbf{F}=\mathbf{F}_{\mbox{\small off}}+\mathbf{G}[\vec{u}]$, where
$\mathbf{G}$ is the cell-centered gradient operator. The nonlinear forces
computed based on this updated gradient are 
$\vec{f}^h(\mathbf{F}_{\mbox{\small off}}^h;\vec{u}^h)$. The FAS procedure is
outlined in Algorithm
\ref{alg_fas_vcycle}. Damped Jacobi is used, albeit with re-linearization steps inserted between every 2-3 Jacobi iterations.

\begin{algorithm}[h]
\caption{FAS V-Cycle  for nonlinear equilibrium equation}\label{alg_fas_vcycle}
\begin{algorithmic}[1]
\Procedure{FASVcycle}{$\vec{f}^h(\mathbf{F}_{\mbox{\small off}}^h;\vec{u}^h)+\vec{g}^h=\vec{0}$}
\State \Call{NonlinearSmooth}{$\vec{f}^h(\mathbf{F}_{\mbox{\small off}}^h;\vec{u}^h)+\vec{g}^h=\vec{0}$}
\State $\mathbf{F}_{\mbox{\small off}}^{2h}\gets\hat{\mathbf{R}}(\mathbf{F}_{\mbox{\small off}}^h+\mathbf{G}^h[\vec{u}^h]),\vec{u}^{2h}\gets\vec{0}$
\State $\vec{g}^{2h}\gets-\vec{f}^{2h}(\mathbf{F}_{\mbox{\small off}}^{2h};\vec{u}^{2h})+\mathbf{R}(\vec{f}^h(\mathbf{F}_{\mbox{\small off}}^h;\vec{u}^h)+\vec{g}^h)$
\State \Call{Solve}{$\vec{f}^{2h}(\mathbf{F}_{\mbox{\small off}}^{2h};\vec{u}^{2h})+\vec{g}^{2h}=\vec{0}$}\Comment{By recursive call}
\State $\vec{u}^{h}\plusequals $Prolongate($\vec{u}^{2h}$)
\State \Call{NonlinearSmooth}{$\vec{f}^h(\mathbf{F}_{\mbox{\small off}}^h;\vec{u}^h)+\vec{g}^h=\vec{0}$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

Our experiments with the fully nonlinear FAS cycle exhibited significant acceleration in certain tasks, but was somewhat more questionable in terms of cost/performance for our typical
use scenario. In particular, when solving for the equilibrium shape following a very sudden skeletal motion (such as fully curling an arm from a full extension, all in a single frame),
the FAS scheme was able to converge in just a few cycles, while the linear multigrid approach would typically necessitate a large number of Newton iterations (even though each linear
system was adequately solved). However, in our typical use, the skeletal motion was relatively incremental, and 1-2 Newton iterations would provide an excellent solution estimate, with
1-2 linear V-cycles as the underlying linear solver. Since the linear cycle is less expensive due to less frequent re-linearization, this approach was overall a better cost/performance
choice for our specific application. Additionally, in the presence of collisions, extreme skeletal motions within a single frame were problematic, since the penalty-based collisions
would easily become tangled in nonphysical configurations. Lastly, we observed that the ability of FAS to make large corrections towards the solution often times had the side effect of
sometimes jumping between different local minima, especially in highly buckled configurations. This behavior can be controlled by augmenting FAS with a linesearch step to prevent it
from tunneling to different minima, but again this was not a priority for our target application.
